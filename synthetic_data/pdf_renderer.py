"""
PDF rendering engine for synthetic magazine layouts.

This module converts the abstract layout elements generated by the layout engine
into actual PDF documents that can be used for testing extraction algorithms.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union
import io
import uuid
from datetime import datetime

try:
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib.colors import Color, black, white
    from reportlab.lib.units import inch, cm, mm, pica
    from reportlab.pdfbase import pdfutils
    from reportlab.pdfbase.ttfonts import TTFont
    from reportlab.pdfbase import pdfmetrics
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image as RLImage
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT, TA_JUSTIFY
    from PIL import Image as PILImage
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False

from .types import (
    LayoutElement, TextElement, ImageElement, ArticleData,
    BrandConfiguration, GenerationConfig, LayoutComplexity,
    EdgeCaseType, SyntheticDataError
)


@dataclass
class RenderingOptions:
    """Options for PDF rendering."""
    
    page_size: Tuple[float, float] = (612.0, 792.0)  # US Letter in points
    dpi: int = 300
    quality: str = "high"  # low, medium, high
    
    # Font settings
    embed_fonts: bool = True
    font_subset: bool = True
    
    # Image settings
    compress_images: bool = True
    image_quality: float = 0.85
    max_image_dpi: int = 300
    
    # Layout settings
    show_debug_boxes: bool = False
    add_crop_marks: bool = False
    
    # Metadata
    include_metadata: bool = True
    add_generation_watermark: bool = False
    
    @classmethod
    def create_high_quality(cls) -> "RenderingOptions":
        """Create high-quality rendering options."""
        return cls(
            dpi=300,
            quality="high",
            embed_fonts=True,
            compress_images=False,
            image_quality=0.95
        )
    
    @classmethod
    def create_test_quality(cls) -> "RenderingOptions":
        """Create fast rendering for testing."""
        return cls(
            dpi=150,
            quality="medium",
            embed_fonts=False,
            compress_images=True,
            image_quality=0.7
        )


class PDFRenderer:
    """Renders magazine layouts to PDF documents."""
    
    def __init__(self, rendering_options: Optional[RenderingOptions] = None):
        if not REPORTLAB_AVAILABLE:
            raise SyntheticDataError(
                "ReportLab is required for PDF rendering. Install with: pip install reportlab"
            )
        
        self.options = rendering_options or RenderingOptions()
        self._font_cache = {}
        self._image_cache = {}
        
        # Register standard fonts
        self._register_fonts()
    
    def _register_fonts(self) -> None:
        """Register fonts for PDF rendering."""
        standard_fonts = {
            "Arial": "Helvetica",
            "Times New Roman": "Times-Roman",
            "Courier": "Courier",
            "Helvetica": "Helvetica",
            "Times": "Times-Roman",
            "Symbol": "Symbol",
            "ZapfDingbats": "ZapfDingbats"
        }
        
        for font_name, pdf_font in standard_fonts.items():
            self._font_cache[font_name] = pdf_font
    
    def render_document(
        self,
        articles: List[ArticleData],
        brand_config: BrandConfiguration,
        output_path: Path,
        generation_config: Optional[GenerationConfig] = None
    ) -> bool:
        """Render a complete magazine document to PDF."""
        try:
            # Create canvas
            c = canvas.Canvas(str(output_path), pagesize=self.options.page_size)
            
            if self.options.include_metadata:
                self._add_metadata(c, brand_config, generation_config)
            
            # Render each page
            page_number = 1
            for article in articles:
                page_range = article.page_range
                for page in range(page_range[0], page_range[1] + 1):
                    self._render_page(c, article, page, page_number, brand_config)
                    if page < page_range[1]:
                        c.showPage()
                    page_number += 1
            
            # Save PDF
            c.save()
            return True
            
        except Exception as e:
            raise SyntheticDataError(f"Failed to render PDF: {str(e)}")
    
    def _render_page(
        self,
        canvas: canvas.Canvas,
        article: ArticleData,
        logical_page: int,
        physical_page: int,
        brand_config: BrandConfiguration
    ) -> None:
        """Render a single page."""
        page_width, page_height = self.options.page_size
        
        # Add debug boxes if enabled
        if self.options.show_debug_boxes:
            self._draw_debug_grid(canvas, page_width, page_height)
        
        # Filter elements for this page
        page_text_elements = [
            elem for elem in article.text_elements 
            if elem.page_number == logical_page
        ]
        page_image_elements = [
            elem for elem in article.image_elements 
            if elem.page_number == logical_page
        ]
        
        # Sort by z-order (back to front)
        all_elements = page_text_elements + page_image_elements
        all_elements.sort(key=lambda x: x.z_order)
        
        # Render elements
        for element in all_elements:
            if isinstance(element, TextElement):
                self._render_text_element(canvas, element, brand_config)
            elif isinstance(element, ImageElement):
                self._render_image_element(canvas, element)
        
        # Add crop marks if enabled
        if self.options.add_crop_marks:
            self._draw_crop_marks(canvas, page_width, page_height)
        
        # Add generation watermark if enabled
        if self.options.add_generation_watermark:
            self._add_generation_watermark(canvas, page_width, page_height)
    
    def _render_text_element(
        self,
        canvas: canvas.Canvas,
        element: TextElement,
        brand_config: BrandConfiguration
    ) -> None:
        """Render a text element."""
        x0, y0, x1, y1 = element.bbox
        
        # Convert coordinates (PDF uses bottom-left origin)
        page_height = self.options.page_size[1]
        pdf_y0 = page_height - y1
        pdf_y1 = page_height - y0
        
        # Set font
        font_name = self._get_pdf_font_name(element.font_family)
        canvas.setFont(font_name, element.font_size)
        
        # Set text color
        r, g, b = element.text_color
        canvas.setFillColor(Color(r, g, b))
        
        # Handle text alignment and rendering
        text_width = x1 - x0
        text_height = y1 - y0
        
        if element.text_align == "center":
            text_x = x0 + text_width / 2
            self._draw_centered_text(canvas, element.text_content, text_x, pdf_y0, text_width, element.font_size)
        elif element.text_align == "right":
            text_x = x1
            self._draw_right_aligned_text(canvas, element.text_content, text_x, pdf_y0, text_width, element.font_size)
        elif element.text_align == "justify":
            self._draw_justified_text(canvas, element.text_content, x0, pdf_y0, text_width, text_height, element.font_size)
        else:  # left align
            self._draw_left_aligned_text(canvas, element.text_content, x0, pdf_y0, text_width, text_height, element.font_size)
        
        # Draw debug box if enabled
        if self.options.show_debug_boxes:
            canvas.setStrokeColor(Color(1, 0, 0, alpha=0.3))
            canvas.setLineWidth(0.5)
            canvas.rect(x0, pdf_y0, text_width, text_height, fill=False)
    
    def _render_image_element(
        self,
        canvas: canvas.Canvas,
        element: ImageElement
    ) -> None:
        """Render an image element."""
        if not element.image_path and not element.image_data:
            # Draw placeholder rectangle
            self._draw_image_placeholder(canvas, element)
            return
        
        try:
            x0, y0, x1, y1 = element.bbox
            page_height = self.options.page_size[1]
            pdf_y0 = page_height - y1
            
            width = x1 - x0
            height = y1 - y0
            
            if element.image_path and element.image_path.exists():
                # Load and draw image from file
                canvas.drawImage(
                    str(element.image_path),
                    x0, pdf_y0,
                    width=width,
                    height=height,
                    preserveAspectRatio=True
                )
            elif element.image_data:
                # Create image from bytes
                img_stream = io.BytesIO(element.image_data)
                canvas.drawImage(
                    img_stream,
                    x0, pdf_y0,
                    width=width,
                    height=height,
                    preserveAspectRatio=True
                )
            
        except Exception as e:
            # Fall back to placeholder on error
            self._draw_image_placeholder(canvas, element)
    
    def _draw_image_placeholder(self, canvas: canvas.Canvas, element: ImageElement) -> None:
        """Draw a placeholder for missing images."""
        x0, y0, x1, y1 = element.bbox
        page_height = self.options.page_size[1]
        pdf_y0 = page_height - y1
        
        width = x1 - x0
        height = y1 - y0
        
        # Draw gray rectangle
        canvas.setFillColor(Color(0.9, 0.9, 0.9))
        canvas.rect(x0, pdf_y0, width, height, fill=True, stroke=True)
        
        # Draw diagonal lines
        canvas.setStrokeColor(Color(0.7, 0.7, 0.7))
        canvas.line(x0, pdf_y0, x1, pdf_y0 + height)
        canvas.line(x0, pdf_y0 + height, x1, pdf_y0)
        
        # Add text
        canvas.setFillColor(Color(0.5, 0.5, 0.5))
        canvas.setFont("Helvetica", 12)
        text = f"[Image {element.width}x{element.height}]"
        text_width = canvas.stringWidth(text, "Helvetica", 12)
        text_x = x0 + (width - text_width) / 2
        text_y = pdf_y0 + height / 2 - 6
        canvas.drawString(text_x, text_y, text)
    
    def _draw_left_aligned_text(
        self,
        canvas: canvas.Canvas,
        text: str,
        x: float,
        y: float,
        width: float,
        height: float,
        font_size: float
    ) -> None:
        """Draw left-aligned text with word wrapping."""
        lines = self._wrap_text(canvas, text, width, font_size)
        line_height = font_size * 1.2
        
        current_y = y + height - line_height
        for line in lines:
            if current_y < y:
                break
            canvas.drawString(x, current_y, line)
            current_y -= line_height
    
    def _draw_centered_text(
        self,
        canvas: canvas.Canvas,
        text: str,
        center_x: float,
        y: float,
        width: float,
        font_size: float
    ) -> None:
        """Draw centered text."""
        lines = self._wrap_text(canvas, text, width, font_size)
        line_height = font_size * 1.2
        
        current_y = y
        for line in lines:
            text_width = canvas.stringWidth(line, canvas._fontname, font_size)
            text_x = center_x - text_width / 2
            canvas.drawString(text_x, current_y, line)
            current_y -= line_height
    
    def _draw_right_aligned_text(
        self,
        canvas: canvas.Canvas,
        text: str,
        right_x: float,
        y: float,
        width: float,
        font_size: float
    ) -> None:
        """Draw right-aligned text."""
        lines = self._wrap_text(canvas, text, width, font_size)
        line_height = font_size * 1.2
        
        current_y = y
        for line in lines:
            text_width = canvas.stringWidth(line, canvas._fontname, font_size)
            text_x = right_x - text_width
            canvas.drawString(text_x, current_y, line)
            current_y -= line_height
    
    def _draw_justified_text(
        self,
        canvas: canvas.Canvas,
        text: str,
        x: float,
        y: float,
        width: float,
        height: float,
        font_size: float
    ) -> None:
        """Draw justified text."""
        # For simplicity, fall back to left-aligned for now
        # Full justification would require word spacing adjustment
        self._draw_left_aligned_text(canvas, text, x, y, width, height, font_size)
    
    def _wrap_text(self, canvas: canvas.Canvas, text: str, width: float, font_size: float) -> List[str]:
        """Wrap text to fit within specified width."""
        words = text.split()
        lines = []
        current_line = []
        
        for word in words:
            test_line = current_line + [word]
            test_text = " ".join(test_line)
            text_width = canvas.stringWidth(test_text, canvas._fontname, font_size)
            
            if text_width <= width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(" ".join(current_line))
                    current_line = [word]
                else:
                    # Word is too long, force break
                    lines.append(word)
                    current_line = []
        
        if current_line:
            lines.append(" ".join(current_line))
        
        return lines
    
    def _get_pdf_font_name(self, font_family: str) -> str:
        """Get PDF font name for given font family."""
        return self._font_cache.get(font_family, "Helvetica")
    
    def _add_metadata(
        self,
        canvas: canvas.Canvas,
        brand_config: BrandConfiguration,
        generation_config: Optional[GenerationConfig]
    ) -> None:
        """Add metadata to PDF."""
        canvas.setTitle(f"{brand_config.brand_name} - Synthetic Magazine")
        canvas.setAuthor("Synthetic Data Generator")
        canvas.setSubject("Generated test data for magazine extraction")
        canvas.setCreator("Project Chronicle - Synthetic Data Generator")
        
        if generation_config:
            canvas.setKeywords(f"synthetic,test,magazine,{brand_config.brand_style.value}")
    
    def _draw_debug_grid(self, canvas: canvas.Canvas, width: float, height: float) -> None:
        """Draw debug grid on page."""
        canvas.setStrokeColor(Color(0.8, 0.8, 1.0, alpha=0.3))
        canvas.setLineWidth(0.25)
        
        # Draw grid lines every half inch
        grid_spacing = 36  # 0.5 inch in points
        
        # Vertical lines
        x = 0
        while x <= width:
            canvas.line(x, 0, x, height)
            x += grid_spacing
        
        # Horizontal lines
        y = 0
        while y <= height:
            canvas.line(0, y, width, y)
            y += grid_spacing
    
    def _draw_crop_marks(self, canvas: canvas.Canvas, width: float, height: float) -> None:
        """Draw crop marks around page."""
        canvas.setStrokeColor(Color(0, 0, 0))
        canvas.setLineWidth(0.5)
        mark_length = 18  # 0.25 inch
        mark_offset = 9   # 0.125 inch from page edge
        
        # Corner crop marks
        corners = [
            (0, 0), (width, 0), (0, height), (width, height)
        ]
        
        for corner_x, corner_y in corners:
            # Horizontal marks
            if corner_x == 0:
                canvas.line(-mark_offset - mark_length, corner_y, -mark_offset, corner_y)
            else:
                canvas.line(corner_x + mark_offset, corner_y, corner_x + mark_offset + mark_length, corner_y)
            
            # Vertical marks
            if corner_y == 0:
                canvas.line(corner_x, -mark_offset - mark_length, corner_x, -mark_offset)
            else:
                canvas.line(corner_x, corner_y + mark_offset, corner_x, corner_y + mark_offset + mark_length)
    
    def _add_generation_watermark(self, canvas: canvas.Canvas, width: float, height: float) -> None:
        """Add generation watermark."""
        canvas.saveState()
        
        # Set semi-transparent gray
        canvas.setFillColor(Color(0.9, 0.9, 0.9, alpha=0.1))
        canvas.setFont("Helvetica", 48)
        
        # Rotate and position text
        canvas.translate(width / 2, height / 2)
        canvas.rotate(45)
        
        text = "SYNTHETIC TEST DATA"
        text_width = canvas.stringWidth(text, "Helvetica", 48)
        canvas.drawString(-text_width / 2, 0, text)
        
        canvas.restoreState()
    
    def render_test_page(self, output_path: Path) -> bool:
        """Render a test page to verify PDF generation."""
        try:
            c = canvas.Canvas(str(output_path), pagesize=self.options.page_size)
            width, height = self.options.page_size
            
            # Add title
            c.setFont("Helvetica-Bold", 24)
            c.drawString(72, height - 100, "PDF Renderer Test Page")
            
            # Add test text
            c.setFont("Helvetica", 12)
            test_text = "This is a test of the PDF rendering system. Font rendering: âœ“"
            c.drawString(72, height - 150, test_text)
            
            # Add test rectangle
            c.setFillColor(Color(0.8, 0.8, 1.0))
            c.rect(72, height - 300, 200, 100, fill=True, stroke=True)
            
            # Add timestamp
            c.setFont("Helvetica", 10)
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            c.drawString(72, 50, f"Generated: {timestamp}")
            
            c.save()
            return True
            
        except Exception as e:
            raise SyntheticDataError(f"Failed to render test page: {str(e)}")


def create_sample_document(output_dir: Path) -> Path:
    """Create a sample PDF document for testing."""
    from .types import BrandConfiguration, TextElement, ArticleData
    
    # Create sample article
    title_element = TextElement(
        element_id="title_001",
        element_type="text",
        bbox=(72, 650, 540, 700),
        page_number=1,
        text_content="Sample Magazine Article",
        font_family="Helvetica",
        font_size=24,
        font_style="bold",
        semantic_type="title"
    )
    
    body_element = TextElement(
        element_id="body_001", 
        element_type="text",
        bbox=(72, 400, 540, 600),
        page_number=1,
        text_content="This is sample body text for testing the PDF rendering system. " * 20,
        font_family="Times New Roman",
        font_size=12,
        semantic_type="paragraph"
    )
    
    sample_article = ArticleData(
        article_id="sample_001",
        title="Sample Magazine Article",
        text_elements=[title_element, body_element],
        page_range=(1, 1)
    )
    
    # Render PDF
    brand_config = BrandConfiguration.create_tech_magazine()
    renderer = PDFRenderer()
    
    output_path = output_dir / "sample_document.pdf"
    renderer.render_document([sample_article], brand_config, output_path)
    
    return output_path